(* $Id: order.sml,v 1.1 1998/07/21 kusakari Exp $
**
**  ver 1.0: 1997/08/01 by KUSAKARI Keiichirou
**  ver 1.1: 1998/07/21 by KUSAKARI Keiichirou
*)

signature SigOrder = sig

    include SigUtil
    include SigTRS

    type 'a Mset

    val mkgrter       : ('a -> 'a -> bool) -> 'a -> 'a -> bool
    val mkeq          : ('a -> 'a -> bool) -> 'a -> 'a -> bool

    val eq_symbol     : (string, int) Assoc -> string -> string -> bool
    val grtereq_symbol: (string, int) Assoc -> string -> string -> bool
    val grter_symbol  : (string, int) Assoc -> string -> string -> bool

    val grtereq_lex   : ('a -> 'a -> bool) -> 'a list -> 'a list -> bool
    val grtereq_lpo   : (string, int) Assoc -> Term -> Term -> bool
    val grter_lpo     : (string, int) Assoc -> Term -> Term -> bool

    val grtereq_mset  : ('a ->'a -> bool) -> 'a Mset -> 'a Mset -> bool
    val grtereq_rpo   : (string, int) Assoc -> Term -> Term -> bool
    val grter_rpo     : (string, int) Assoc -> Term -> Term -> bool

end;

structure Order : SigOrder = struct

    open Util;
    open TRS;

    type 'a Mset = 'a list;

    (* Let "gsim" be quasi-ordering.
     * "mkgrter" convert "gsim" to strict partial ordering.
     * "mkeq" also convert it to equivalence relation.
     *)

    fun mkgrter gsim x y = gsim x y andalso not (gsim y x);

    fun mkeq gsim x y = gsim x y andalso gsim y x;

    (*
     -- Partial ordering on Symbols
     --      You must prepare list which maps symbols to integers.
     --      For example,
     --           ol = [("0",1),("S",1),("P",3),("M",4),("F",5)]
     --      Other symbols without orderlist such as "x",
     --      have only trivial relation: "x" >= "x".
     *)

    fun eq_symbol ol x y =
        if x = y then true
        else case (find x ol, find y ol)
               of (SOME n, SOME m) => n = m
                | _ => false;

    fun grtereq_symbol ol x y =
        if x = y then true
        else case (find x ol, find y ol)
               of (SOME n, SOME m) => n >= m
                | _ => false;

    fun grter_symbol ol x y =
        case (find x ol, find y ol)
          of (SOME n, SOME m) => n > m
           | _ => false;

    fun grtereq_lex .....

    fun grtereq_lpo .....
    and grter_lpo .....

    fun grtereq_mset .....

    fun grtereq_rpo .....
    and grter_rpo .....

end;
